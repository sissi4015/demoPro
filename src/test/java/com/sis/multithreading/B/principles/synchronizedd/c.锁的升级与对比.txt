《Java并发编程的艺术》

第二章 Java并发机制的底层实现原理

2.2 synchronized的实现原理和应用

重点5：锁的升级与对比

        在Java SE 1.6中，锁的4种状态：
            无锁状态
            偏向锁状态
            轻量级锁状态
            重量级锁状态
        这几个状态会随着竞争情况逐渐升级
        ！！！锁可以升级，不能降级。这种策略是为了提高获得锁和释放锁的效率

        1.偏向锁
            1）原理：
                当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID
                该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，
                    只需要简单的测试一下对象头的Mark Word里是否存储这当前线程的偏向锁
                    如果测试成功，表示已经获取了锁
                    如果测试失败，再测试一下Mark Word中偏向锁的标志是否设置成了1（表示当前时偏向锁）
                        如果没有设置，则使用CAS竞争
                        如果设置了，尝试使用CAS将对象头的偏向锁指向当前线程

            2）偏向锁的撤销
                偏向锁使用了一种等到竞争出现才释放锁的机制。

                偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。
                    首先暂停拥有偏向锁的线程
                    然后检查持有偏向锁的线程是否活着
                        如果线程不是活跃状态，将对象头设置为无锁状态
                        如果线程仍然活着，拥有锁的栈会被执行，遍历偏向对象的锁记录
                            栈中的锁记录和对象头的Mark Word：
                                要么重新偏向于其他线程，
                                要么恢复到无锁状态
                                或者标记对象不适合作为偏向锁
                    最后唤醒暂停的线程


            3）关闭偏向锁
                偏向锁在Java 6和Java 7中默认是启用的，但是它在应用程序启动几秒之后才会激活，
                    如果必要，可以使用JVM参数-XX:BiasedlockingStartupDelay=0关闭延迟
                如果确定应用程序中所有的锁通常情况下处于竞争状态，
                    可以使用JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false
                        那么程序会默认进入轻量级锁状态

        2.轻量级锁
            1）加锁
                执行代码块之前，
                    JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，
                    并将对象头中的Mark Word复制到锁记录中（Displaced Mark Word）
                    然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针
                        如果成功，当前线程获得锁
                        如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁

            2）解锁
                轻量级锁解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头
                    如果成功，则表示没有竞争发生
                    如果失败，表示当前锁存在竞争，锁就会膨胀成为重量级锁

            因为自旋会消耗CPU，为了避免无用的自旋，升级成重量级锁，就不会再恢复到轻量级锁状态。
            当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，
                被唤醒的线程会进行新一轮的竞争。

        3.锁的优缺点对比
            偏向锁
                优点：加锁解锁都不需要额外的消耗，和执行行非同步方法相比仅存在纳秒级的差距
                缺点：如果线程间存在锁竞争，会带来额外的锁撤销的消耗
                适用场景：只有一个线程访问同步块的场景
            轻量级锁
                优点：竞争的线程不会阻塞，提高了程序的响应速度
                缺点：如果始终得不到锁竞争的线程，使用自旋会消耗CPU
                适用场景：追求响应时间，同步块执行速度非常快
            重量级锁
                优点：线程竞争不使用自旋，不会消耗CPU
                缺点：线程阻塞，响应时间慢
                适用场景：追求吞吐量，同步块执行速度较长




