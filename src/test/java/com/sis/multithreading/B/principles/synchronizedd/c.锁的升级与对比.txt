《Java并发编程的艺术》

第二章 Java并发机制的底层实现原理

2.2 synchronized的实现原理和应用

重点5：锁的升级与对比

        在Java SE 1.6中，锁的4种状态：
            无锁状态
            偏向锁状态
            轻量级锁状态
            重量级锁状态
        这几个状态会随着竞争情况逐渐升级
        ！！！锁可以升级，不能降级。这种策略是为了提高获得锁和释放锁的效率

        1.偏向锁
            1）原理：
                当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID
                该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，
                    只需要简单的测试一下对象头的Mark Word里是否存储这当前线程的偏向锁
                    如果测试成功，表示已经获取了锁
                    如果测试失败，再测试一下Mark Word中偏向锁的标志是否设置成了1（表示当前时偏向锁）
                        如果没有设置，则使用CAS竞争
                        如果设置了，尝试使用CAS将对象头的偏向锁指向当前线程

            2）偏向锁的撤销
                偏向锁使用了一种等到竞争出现才释放锁的机制。

                偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。
                    首先暂停拥有偏向锁的线程
                    然后检查持有偏向锁的线程是否活着
                        如果线程不是活跃状态，将对象头设置为无锁状态
                        如果线程仍然活着，拥有锁的栈会被执行，遍历偏向对象的锁记录
                            栈中的锁记录和对象头的Mark Word：
                                要么重新偏向于其他线程，
                                要么恢复到无锁状态
                                或者标记对象不适合作为偏向锁
                    最后唤醒暂停的线程


            3）关闭偏向锁
                偏向锁在Java 6和Java 7中默认是启用的，但是它在应用程序启动几秒之后才会激活，
                    如果必要，可以使用JVM参数-XX:BiasedlockingStartupDelay=0关闭延迟
                如果确定应用程序中所有的锁通常情况下处于竞争状态，
                    可以使用JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false
                        那么程序会默认进入轻量级锁状态



